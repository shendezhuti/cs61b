


cs61b听课笔记&问题

2019/4/30
1.course overview & using objetcts

Goal of cs61b
1)learning efficient data structure&algorithms
2)designing&writing large programs
3)understanding&designing data abstraction &interfaces
4)learning java

objected-oriented programming
object: a repository of data
class: type of object
method: procedure of function that operates on an object
Inheritence: A class may inherit properties from a more general class
	shoppingList inherit from list

polymorhism: one method works on several classes, even if the classes need different implementions 
	e.g. "additem" method on every kind of List, though adding item to a shoppinglist is different from a shopping cart

ojbect-oriented: each object knows its own class & method 

Java 
variable: you must declare them and their type
		int x;
		x=1;

does 2 things:
(1)allocates memory to store on integer, type "int".
(2)names variable "x".			

variables also used to reference objects

2 ways to get classes:
(1)use one defined by somebody else. Java has tons 
(2)define your own.					

String myString;	<-varibale (not object)
		mySring=new String();
2 steps:
		new String() is a constructor
		assignment "=" causes myString to reference the object

java programs must be compiled before you can run them

Java  Java program(.java) -javac-> .class files -java-> answer  
													JVM do the job

Object & Constructors
String s;
String s2=s;
s="Yow!"
s2="Yow!" 

s2=new String(s) 有五步操作
(1)look where s points
(2)follows reference to string object
(3)reads string 
(4)consturct new string w/copy of character
(5)make s2 reference new String

Methods
s2=s.toUppercase();

I/O class & object
Object in System class for interacting with a user
System.out is a Printstream object that output to the screen
System.in is an Inputstream object that reads from the keyboard 这里其实是指reference

To use Java libraries, other than java.lang, we "import" them 
java.io includes InputStreamReaders, BufferedReader, etc .

2.defining classes

unix/vim help session  真滴羡慕ucb的学生
Fields: variable stored in objects  
		aka instance variavle 

Defalut constructor takes no parameter, does no initializing
只写一个constructor defalut constructor gone

The "this" keywod 
amanda.introduce() implicitly pass an object (amanda) as a parameter called "this"
local variable 相比于 field varibale more priority(更具有优先级)

IMPORTANT: You cannot change the value of "this"
this.amanda; -> compiler error

the "static" keyword
static field: a single variable shared by a whole class of objects 
also called class variable

System.in & System.out are static fields

static method: does not implicitly pass an object as a parameter

IMPORTANT: In a static method,there is no "this"!!
referencing "this" ->compile-time-error


3.Types: conditions
byte: 8-bit integer -128-127
short: 16-bit -32768-32767
int: 32bit 
long: 64bit 
double: A 64-bit floating-point number 
float: 32-bit 
boolean: "true" or "false"
char: A Character23
	long x=43L;
	double & float values must have a decimal point.
	double y=18.0;
	float f=43.9f;

	char c='h';

					object type  		primitive types 
contains a    		reference			value
how defined	  		class definition	built into java
how initialized?	Constructors 		defalut
how used			Methods 			operators 

java.lang library :
		--Math class
		x=Math.abs(y);  x=Math.sqrt(y);
		--Interger class
		int x=Integer.parseInt("1998");
		--Double class
		double d=Double.parseDouble("3.14");

	Integer can be assigned to variables of larger types
		int i=43;
		long l=43;
		l=i ; 
		i=l;		//compiler error
		i=(int)l;

	Boolean values 
		"true" or "false"

CONDITIONALS
	if(boolValue){
	statements;
	}

	boolean pass=score>=75;

THE "return" KEYWORD

"return" causes a method to end immediately 
control returns to the calling method

return is means by which a function returns a value;

function: method declared to return a non-void type

Loops 
"while" loops 
public static boolean isPrime(int n){
	int divisor=2;
	while(divisor<n){
	if(n%divisor==0){
		return false;
	}
	divisor++;
	}
	return true;
}	

Iteration: a pass through the loop body
if n<=2, the loop body won't iterate ever once

"for" loop
for(initialize;condition;next){
	statements;
}		

Arrays 
An object storing a numbered list of variables 
Each is a primitive type or reference

char[]c; //reference to array(any length) of characters
c=new char[4];
c[0]='b';
c[3]='e';
c[4]='s'; //run-time error

Field "c.length"

Primes Revisited
Sieve of Eratosthenes

public staticvoid printPrimes(int n){
	boolean []prime= new boolean[n+1];
	for(int i=2;i<=n;i++){
	prime[i]=true; //prime until proven composite
	}
	for(int divisor=2;divisor*divisor<=n;divisor++){
	if(prime[divisor]){
		for(int i=2*divisor;i<=n;i=i+divisor){
		prime[i]=false;
		}
	}
	}
}

Muti-dimensional Arrays
2D array: Array of reference to arrays

Pascal's Triangle  

Loop & arryas II
Aytimatic Array Construction
int [][]table=new int[x][y];

Initializers: 
	Human[]b={amanda,rish,new Human{"pdob"}};

int[]a,b,c; //all reference arrays
int a [],b,c[][]; // a is 1D;c is 2D;b is not array
int [] a, b[];  // a is 1D; b is 2D;

int []b[]= new int [3][];
int []b[]=new int [][3];  compile error

when you construct array of objects, 
java does not construct the objects 

main() parameter
List of command-line arguments

"do" loops

do{
	s=keybd.readLine();
	process(s);
}while(s.length>0)

s=keybd.readLine();
while(s.length()>0){
	process(s);				disadvantage:如果duplicate code有几百行就gg了
	s=keybd.readLine();
}

while(true){
	s=keybd.readLine();
	if(s.length()==0){
	break;					disadvantage : illegial 
	}	
	process(s);
}


"go to" is harmful ?

continue
(1)only applies to loops
(2)jumps to end of loop body but another iteration commerence if loop condition satisfied

CONSTANTS
"final" keyword: value that can never be changed
bad: if(month==2) 
good: public static int February=2;
	 if(month==February)

for any array x, "x.length" is a "final" field	

hw2错点：
静态方法不能调用非静态方法！！！ 

Lists  	Array-based lists
Advantage: very fast access of each item
2 disadvantage: 
 			（1)insert item at beginning or middle 
 				takes time proportional to length of array
 			 (2) array has a fixed length 

 LINKED LISTS   (a recursive date type)
 Make up of nodes. Each node has:
 (1)an item
 (2)a reference to next node in list

 public class ListNode {
 	public int item;
 	public ListNode next;
 }

 l1.next=l2;
 l2.next=l3;
 l3.next=null;

 public ListNode(int i, Listnode n){
 	item=i;
 	next=n;

 }
 public ListNode(int i){
 	item=i;
 	next=null;
 }

 ListNode l1=new ListNode(7,new ListNode(0,new ListNode(7)));

 Linked Lists vs array lists

 advantage of linked lists
 Inserting item into middle of linked list takes constant time
 if you have a ref to previous node 

List can keep growing out until memory runs out

Insert a new item:
public void insertAfter(int item){
	next=new ListNode (item,next);  //可以画一个图理解 注意里面的两个next是不一样的
}

disadvantage: Finding  nth item of a linkedlist
		start at head, walk n-1 nodes.

List Of Objects  reference any object

public class  SListNode {		s->singlelinkedlist
	public object item;
	public SlistNode next;
}

A List class
problem with SListNodes:
(1)Insert new item at beginning of list:  x=new SListNode("soop",x);
(2) how do you represent an empty list?
x=null; x.insertAfter(item) //run-time error

solution: separate SList class maintain the head of the list

public class SList{
	private SListNode head;
	private int size;
	public SList(){
	head==null;
	size=0;
	}
	public void insertFront(Object item){
		head=new SListNode(item,head);
		size++;
	}
}

The "public" and "private" keywords
private method or field: invisible & inaccessible to other classes
why????

(1)to prevent data from being corrupted by other classes
(2)you can improve the implementation without causing other classes to fail

The interface of a class: prototypes for public methods  ->java code
			plus description of their behaviors: plain English

Abstract Data Type (ADT): A class with well-defined interface, but implementation detail are hidden from other classes

Invariant:  A fact about a data strucure that is always true
			"A Date object always stores a valid date"
		Enforced by allowing access only through method calls

Not all classed are ADTs! some classes are data storage units, no invartants;field can be public 

The SList ADT
another advantage of SList class: it enforces 2 invariants;
(1) "size" is always correct
(2)A list is never circularly linked, 
Both goals accomplish because only SList methods can change the lists.
	SList ensure this:
	(1)The fields of SList(head & size) are "private".
	(2)No method of SList returns an SListNode .

DOUBLY-LINKED LISTS

Inserting/deleting at front of list is easy.
						end of lists takes a long time;

class DlistNode{
	Object item;
	DListNode next;
	DListNode prev;
}

class DList{
	private DListNode head;
	private DListNode tail;
	long size;
}

insert & delete items at both ends in constant running time

Removes the tail node (at list 2 items in DList):
	tail.prev.next=null;
	tail=tail.prev;

Sentinel: A special node that does not represent an item.

DList invariants (with sentinel)：
(1)for any DList d, d.head!=null
(2)For any DList x, x.prev!=null;
(3) "  "  " " , x.next!=null;
(4)"	" "	", if x.next==y,then y.prev==x;
(5) "	" "	", if x.prev==y,then y.next==x;
(6) A DLists "size" variable is DListNodes, not couting sentinel ,accessible from sentinel by sequence of "next" s .

public long size(){
	
}
Empty DList: Sentinel prev & next field points to itself

public void removeBack(){
	if (head.prev!=head){
	head.prev=head.prev.prev;
	head.prev.next=head;
	size++;
	}
}


The stack and the heap

the heap stores all object; include all arrays & class variables
the stack stores the local variable ,including parameter
when a method is called, java creates a stack frame (aka activation record);
stores the parameters & local variables
stack of stack frames 

gc affect the heap only

when a method finished, its stack frame is erased.
Method "Thread.dumpStack()" for debugging

Parameter passing 
Java passes all parameter by value: copied 

class IntBox{
	static void doNothing(int x){
	x=2;
	}
}

int a=1;
doNothing(a);

when parameter is a reference, the reference is copied, but the object is shared.

Common programming error

static void badSet4(IntBox ib){
	ib=new IntBox();
	ib.i=4;
}

Binary Search 
Searches a sorted array.
If we find "findme", return its array index;
otherwise,return faliure.

Recursion base cases:
(1)findMe==middle element: return its index
(2)subarray of length zero: return failure

Monday: President's Day
no lecture/office hours/discussion sections

INHERENTENCE

public class TailList extends SList{
	// "head" & "size" inherited from SList
	private SListNode tail;

}

TailList is subclass of SList
SList is the superclass ot TailList
A subclass can modify a superclass 3 ways
(1)It can declare new fields
(2)"	" "	" "	"	 new methods
(3)" " override old methods with new implementations

public void insertEnd(Object obj){
	//you solution to lab3
}
isEmpty(), length(), nth(), toString() are inherited from SList

Inheritance & construnctors 
Java execute TailList constructor before it executes any code.

public TailList(){
	// SList()  set size=0, head=null;
	tail=null;
}

public TailList(int x){
	super(x);  <- must be first statement in constructor
	tail=null;
}

Invoking Overriden methods 
public void insertFront(Object obj){
	super.insertFront(obj);
	if(size==1){
	tail=head;
	}
}

The "protected" keyword

public class SList{
	protected SListNode head;
	protected int size;
}

"protected" field is visible to declaring class & all its subclass but no others.
"private" fields aren't visible to subclass

Class Hierarchies 
				Object  
			String   worker
		student  ta 	professor

Dynamic Method Lookup
		Every TailList is an SList!!!
	SList s= new TailList();
	TailList t=new SList();  // Compile-time error!

Static type: the type of a variable
dnamic type: the class of the object the variable reference

when we invoke overridden method, Java calls methods for ojbect dynamic type, regardless of static type 

SList s=new TailList();
s.insertEnd(obj); //calls TailList.insertEnd();
s=new SList();
S.insertEnd(obj); 	//calls SList.insertEnd();

WHY DYNAMIC METHOD LOOKUP MATTERS
Method that sorts an SList using only SList method calls
Method that sorts an TailList too.

Subtltties of Inheritance
(1) new method in TailList--eatTail();
		TailList t=new TailList();
		t.eatTail();

		SList s=new TailList();
		s.eatTail(); 	//compile-time error
Why? Not every sList has an "eatTail()" method.
so Java can't use dynamic method lookup on s.

(2) SList s;
	TailList t= new TailList();
	s=t;
	t=s;		//compile-time error
	t=(TailList) s;

	s=new SList();
	t=(TailList)s;	//runtime error : classcastException

	int x=t.nth(1).intvalue();	//compile-time error
	int y= ((Integer)t.nth(1)).intValue();

(3) "instanceof" operator tells you whether object is of specfic class.
	
	if(s instanceof TailList){
		+=(TailList) s;
	}
return false is s is null or does not reference to a TailList
		true if s reference a TailList or subclass

equals() every class has an equals() method.
Default: inherit Object.euqals()
		r1.equals(r2) same as "r1==r2"
		run-time error if r1 is null

Many classes override equals() to compare content.
e.g Integer 
	i1==i2 false ;
	i1.equals(i2) true;

	i2==i3 true   ;
	i2.equals(i3) true;

Four degrees of quality: 
(1) reference equality, ==
(2) Shallow structural equality :  fields are ==
(3) deep structural equality : fields are .equals();
(4) logical equality 
	
	"set" objects are "equals" if they contain some elements 
	(even in different orders)

	Fractions 1/3 and 2/6 are "equals".
equals() may  test any of these 

public class SList{
	public boolean equals(Ojbect other){ not SList!!! signature must be the same as Object equals

	if(!(other) instanceof SList){
	return false;
	}
	SList o=(SList) other;
	if(size!=o.size){
	return false;
	}
	SListNode n1=head;
	SLsitNode n2=o.head;
	while(n1!=null){
	if(!n1.item.equals(n2.item)){
		return false;
	}
	n1=n1.next;
	n2=n2.next;
	}
	return true;
	}
}

"for each" Loops 
Iterate through array elements
	int []array={7,12,3,8,4,9};
	for(int i:array){
	System.out.print(i+"");
	}


TESTING 

(1) Modular Testing   	
	Test driver & stub 
	a:test driver call the code, check results
	b stubs: bits of code called by the code being tested

(2)Integration Testing 
	testing all components together

	define interfaces well
	learn to use a debugger.

(3)	result verfication 
	a: data structure integrity checkers
	Inspect a datastructure & verify that all invariants are satisfied.

	b: algorithms result checkers

assertion: code that tests an invariant or a result.
	assert x==3;
	aserrt list.size==list.countLength();
			"wrong SList size" + list.size;
	turn them on: java -ea 
	turn them  off:	 java -da  (greater speed)


ABSTRACT CLASSES
a class whose sole purpose is to be extended 
public abstract class List{
	protected int size;
	public int length(){
	return size;					//ADT(abstract data type)
	}
	public abstract void insertFront(Object item);
}

List myList;
myList =new List(); // compile-time error
Abstract method lacks an impletation 
public class SList extends List{
	//inherits "size"
	protected SListNode head;
	//inherits "length()"

	public void insertEnd(Object item){
		head=new SListNode(item,head);
		size++;
	}
}

A-non-abstract class may never 
 contain an asbstract method
 inherit one without providing an implementation

 List myList=new SList();
 myList.insertFront(obj);  compiles because everyList has an insertFront method
 myList.head =   //compile-time error( not every List has a "head" field)

 ((SList)myList).head=  //this complie and myList is still List static type while the expression
 								((SList)myList) is SList static type

 An abstract class lets you define an interface for multiple class to share,
 without defining any of them yet.

one List sorter can sort every kind of List 

public void listSort(List l){
	
}

subclass: SLsit,DList,tailList
TimeList 
TransanctionList

JAVA INTERFACE

"interface" : public field method prototype & behaviors 

"Java interface":  "interface" keyword. 

Java interface is like abstract class. 2 differences
(1) A class inherit from only one class
	can "implement" (inherit from ) many Java interfaces 
(2) A java interface cannot 
	implement any methods 
	include any field except "final static" constants
	only contains method protoytpes & constants

public interface Nokeable{
	public void nuke();  //assumed abstract
}

public interface Comparable { // in java.lang
	public int compareTo(Object o);
}

public class SList extends List implement Nukeable, Comparable {
	pulibc void nuke(){
		head=null;
		size=0;
	}

	public int compareTo(Object o){
		[return a number <0 if this<o,
		return 0 if this.equals(o),
		return >0 if this>0  ];
	}
}

Nukeable n= new SList();
Comparable c= (Comparable)n;

Arrays class in java.util sorts arrays of comparable objects

public static void sort(Object[]a) 

A subinterface can have mmutiple superinterface.

public interface NokeAndComparable extends Nokeable,Comparable{};

JAVA PACKAGES 

package: collection of classes, Java interfaces, & packages 
			that trust each other.
3 benefits (1)packages can contain hidden class not visible outside package
			(2) classes can have fields & methods visible inside package only 
			(3) different package can have class same name

			java.awt.Frame  		photo.Frame

	Examples 
	(1) java.io 
	(2) homework 4  uses "list" package containing DList & DListNode 
	(3) java.awt.image Model

Using Packages

Fully-qualified name
	java.lang.System.out.println(" ");
import java.io.File;	//Can now refer to File
import java.io.*; //everything in java.io

Every program imports java.lang.*;
java.awt.Frame.add(photo.Frame.canvas);

Building Packages 
/* list/SList.java */			/* list/SListNode.java */

package list;					package list;

public class SList{				class SListNode{
	SListNode head;
	int size;
}

"package" protection 
between "private" and "protected" 

A class or variable w/package protection is visible to any class in same package,but not any 
thing outside the package (i.e. files oustside the directory).

HW4: DListNode class is public 

"prev" & "next" have package protetion, so application cannot corrupt DList ADT.

public class must be declared in file named after class.
"package" classes can appear in any  . java file

Compiling and running must be done from ousside package
	javac -g list/SList.java 
	java list.sList


"public "
"protected"
"default"(package)
private	

ITERATORS 

public interface Iterator {
	boolean hasNext();
	Object next();
	void remove(); //optional
}

An Iterator is like a boomark.

can have many Iterators in some data structure

Calling next() nth time return nth item in sequence.
subsequent calls to next() throws an exception.
hasNext():true iff more items to return 

public interface Iterable {
	Iterator iterator();

}

DS.iterate()   constructs a DSIteraotr for DS.  

"for each" loop iterates over item in data structure 

for(Object o:l) {   // l-> SList implements Iterable
	System.out.println(o);
}

equivalent to:

for(Iterator i=l.iterator();i.hasNext()){
	Object o=i.next();
	System.out.println(o);
}

EXCEPTION

Run-time error:Java "throw an exception"
(Exception object).  Prevent the error by "catching" the Exception.
purpose: Copying with Errors
try{
	f=new FileInputStream("cs61b/pj2.solution");
	i=f.read();
}catch(FileNotFoundException e1){	e1-> variable declaration
	System.out.println(e1);		Exception handlers
}
	catch(IOException e2){	both e1 and e2 are subclass of Exception
	f.close();					
	}

(a) executes the code inside "try" clause.
(b) if "try" code executes normally skip "catch" classes.
(c) if "try" code throws an exception; do not finish the "try" code.
(d) Jump to first "catch" clause that matches exception;
	executes.		"match":exception object thrown is same class/subclass of the type in "catch" clauses

Purpose#2 : Escapsing a Slinking ship

throw your own exception 

public class ParseException extends Exception {}
				distinguishable from other types of exceptions

public ParseTree parseExpression()throws ParseException{
	[loops]									required!!
	if(something wrong){
		throw new ParseException();
	}									
}				

Different from "return"?
1.do not return anything
2.an exception can propagate several stack frames down the stack .

public ParseTree parse()throw ParseException,DumbCodeException{
	[loops and code]
	p=parseExpression();
	[more code]
}

public void compile(){
	ParseTree p;
	try{
	p=parse();
	p.toByteCode();
	}catch(ParseException e1){

	}
	catch(DumbCodeException e2){

	}
}


Checked and unchecked Throwables

											Throwable
							excpetion 											error
	IOException						RunTimeException					assertionError		virtualMachineError
			    		classcastException					NullPointerExcetpion				outofMemoryError

catching an error is rarely appropriate

unchecked Throwables do not require "throws" clause
All exceptions except RunTimeException are checked

when a methods calls a method taht can throw a checekedexception
(1)it can catch the exception the exception,or 
(2)it throws same exception itself.

the finally keyword

f=new FileInputStream("filename");
try{
	statement x;
	return 1;
}catch(IOException e){
	e.printStackTrace();	<- when exception is constructed,i taks a snapshot of stack
	return 2;
}finally {
	f.close();
}

if "try" statement begins, the "finally" clause will excute at the end, no matter what!

It statement x causes no exception-> "finally" clause executed, 1 returnred.

If statement causes IOException -> "catch"clause excutes,then "finally" clauses 2 return

If statement causes some other exception -> "finally" "excutes",then exception continues down the stack

Exception throw in "catch" clauses terminate the "catch" clauses, execute "finally",exception continues down stack

Exception throw in "finally" clause: replace old exception, "finally" clause & method end

Exception constructors

Convention: Most Throwables have 2 constructors

class MyException extends Exception {
	pulibc MyException (){super();}
	public MyException(String s){super(s);}	error message
}

error message

printed if it propagates out of main();
can be read by Throwable.getMessage().

Generics 

declare general class that produces special object
SList for String, SList for Integers, only SList class
SList takes a type parameter. 
class SListNode<T> {
	T item=;
	SListNode<T> next;

	SListNode(T i, SListNode<T> n){
		item=i;
		next=n;
	}
}
public class SList<T>{	<- T is formal type parameter
	SListNode<T> head;
	public void insertFront(T item){
	head=new SListNode<T>(item,head);

	}
}

create an SList of Strings:
	SList<String> l=new SList<String> ();		<-String is an actully tpye parameter
	l.insertFront("hello");
	String s= l.front().item();

Advantages: Compiler ensures at compile time that nothing but strings enters your SList<String> . 
Easier to debug than ClassCastExceptions much later!
in java Generic is only for Object 

Field SHADOWING

field can be "shaddowed" in subclass 
different from overrding .

choice at methods dictated by dynamic type
choice of fields dictated by static type

class super{				class Sub extends super{
									int x=4;	
	int x=2;						inf (){
									return 4;	
	int f(){					}
	return 2;
	}
}
	
Sub sub=new Sub();
Super supe=sub;
int i;
i=supe.x;		//2
i=sub.x;		//4
i=((super)sub).x //2
i=((sub)).x;  //4

Shadowing is a nuisance 

static methods follow same shadowing rules as fields.

"final" methods & classes 

"final" method-> cannot be overridden 
"final" class -> cannot be be extend 



Game Tree Search  Tic Tac Toe  google it!

assume both opponents are infinitely intelligent
Each grid is assigned a numerical score that indicateds how optimistim we are about winning 
1:computer is guaranteed a win.
-1:opponents guaranteed a win.
0:perfect players will draw 

Score a grid? suppose computer is X.
3 X's in a row :1 
3 O's in a row :-1
No empty quares, nobody has won: 0

Any other grid : minimax algorithm

(1)consider each possible move; determine child grid.
(2)score each child grid by calling minimax recursively
(3)assign a score to parent grid

computer's turn "choose move that yields maxmum score".

opponets's turn "choose move that yield minmun score"

public Best chooseMove(boolean side){
	Best myBest=new Best();		//My best move
	Best reply;				//opponent's best reply 
	if(this grid is full or has a win){
	return a best with the grid's socre,no move;
	}
	if(side==COMPUTER){
	myBest.score=-1;
	}else{
	myBset.socre==1;
	}
	myBest.move=any legal move; // make sure more is always initialized 
	for(each legal move m){
		perform move m;
		reply =chooseMove(!side); //recursive minimax an children
		undo move m;	//reverse "this" grid
		if((side==COMPUTER&&reply.score>myBestscore)||(side==HUMAN&&reply.score<myBest.score)){
			myBest.move=m;
			myBest.score=reply.score;
		}
	}
	return myBest;
}

Each grid in game tree represtent are invovation of chooseMove();

simple prunning 
	if a player discovers a guranteed winning move 
	there's no reason to search for a better move .

Alpha-beta Pruning 

Computer has dicovered a move (A) that guarantees a draw;
is investigating an alternative move(B).
Discover that if opponents moves X in response,the opponents can force a draw,
the opponent can force a draw.
stop investigating B

∂: a score that computer knows it can achieve 
ß:a score that opponent knows it can achieve

if ß becomes <= ∂, further investigation of current grid is useless

ENCAPSULATATION
Module:A set of methods that work together to perfrom some task.

A module is encapsulated if its implementation is hidden, & it can be accesssed only through a documentted interface.

ADT: Encapsulated date structure. 
not all modules are ADTS.

Algorithms (list sorters) & applications (netword routing software) can be encapsulated

public class ListManager {
	
	list.head.next=list.head.next.next;	// violation of data hidding 
}

This kind of bug is one of the most difficult to find & fix 

Application

  |interface|

  |	module or		|
  |	Abstract Data type		|
  |			|
  |			|

 Data can only go in & out through the interface.

 why encapsulation is your friend ?

 (1)the implementation is independent of the functionality
 	->with the interface documentation, you can implement a new version independently.
 	->New , better implementation can replace old one.
 (2)Prevents everyone from corrupting a modules internal data.
 (3)ADTS can guarantee their invariants are preserved 
 (4)Teamwork. Once you've define interfaces, each programmer can independtly implement a module.
 (5) Documentation & maintainability. 
 (6) pj2 doesn't work?? Easier to point the blame
 (7) An interface is a CONTRACT between module writers, specifying exactly how they will communicate

 Enforcing encapsulation
 Many language: self-discipline.
 Java : package & "private", package, & "protected "

 not always enough, e.g. many modules in some package.

 pj2: could put all modules in "player" package.

 One way to selef-discipline: different team member work on each module. Neither team member reveals code to others. 

 project 2 
 Document interface in GRADER before you start programming. Allows you to work as a team.

 		Machine Player

 	game tree search module 

evalution function 		
						network identifier

Modules must be independent and communicate through simple interfaces. 

A module is organized around functionality it provides.
A class is organized around a data storage unit.

A module can be made up of several classes;
a class can be made up of several moduels. 
	Module might implement data structure made of several classes 
e.g. List=list object +node objects.

class can support many independent operations.
game tree search; evaluation function; network id.
all operate on game board .

A module may include many methods or few.
A package may contain are modue or many.

Project 2 documentation: 
-List the modules.  
-For each modules, specify its interface. 
o Prototype(s) for methods available for external callers:
o Comment that describes behavior from external point of view.

o Describe every parameter & return value.

complete & unamiguous 
interfaces appears in both GRADER and code.

ENCAPSULATED LISTS (a case study)
hw 3,4,5 : Three different linked lists;

hw3 lists: query every item : O(n^2) time. (use nth(i),takes time ∂ i)
hw 4,5: Application can hold a node.
		Query every time in O(n) time 

hw 5 SList & DList are well-encapsulated 
hw 4 DList had flaws. 

(1)what if l.remove(n); -but node n is a different list than l!
	hw4: "size" field of wrong list is updated!
	fix? 
	ADT interface fix: remove(), insertAfter(),etc. should update the right list's "size"!
	implementation fix : every node keeps a reference to list that controls it .
	hw5: "mylist" 
(2)should insertAfter(),remove(), etc. be methods of List or ListNode 

	ADT interface fix:
		 List    	


		Implementation fix: Each node has "myList" field, 
							update correct list's "size". 
(3)what if l.remove(n), l.insertAfter(i,n) 	


calling remove(n) twice on same node also corrupts "size"
	fix?

	ADT interface fix: After n.remove(n), n is  "invalid", any attempts to use n throws exception

Implementation fix:  n.remove()-> n.myList set to null. (mark n invalid) 						


(4) what if we walk off end of list? (using next());

ADT interface answer: 	
		hw4 :return null.
		hw5 : return invalied node .
		 provide some consistency: tail.next() & remove()give some result.
		 n.next.item() -> hw5 it throws InvalidNodeException 
		 				hw4 it throws NullPointerException 
		 				Eliminates ambiguity .

		 Implements that answer:  any sentinel is an invalid node.

(5) How do we access an item ?
	ADT interface answer: 
		hw4: Node's "item" is public .
		hw5: ""   is protected, application must use item() & setitem(). why??
		Application can't store items in deleted nodes or sentinels. 

	ADTs should never do more than the documentation says 		 

