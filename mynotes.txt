


cs61b听课笔记&问题

2019/4/30
1.course overview & using objetcts

Goal of cs61b
1)learning efficient data structure&algorithms
2)designing&writing large programs
3)understanding&designing data abstraction &interfaces
4)learning java

objected-oriented programming
object: a repository of data
class: type of object
method: procedure of function that operates on an object
Inheritence: A class may inherit properties from a more general class
	shoppingList inherit from list

polymorhism: one method works on several classes, even if the classes need different implementions 
	e.g. "additem" method on every kind of List, though adding item to a shoppinglist is different from a shopping cart

ojbect-oriented: each object knows its own class & method 

Java 
variable: you must declare them and their type
		int x;
		x=1;

does 2 things:
(1)allocates memory to store on integer, type "int".
(2)names variable "x".			

variables also used to reference objects

2 ways to get classes:
(1)use one defined by somebody else. Java has tons 
(2)define your own.					

String myString;	<-varibale (not object)
		mySring=new String();
2 steps:
		new String() is a constructor
		assignment "=" causes myString to reference the object

java programs must be compiled before you can run them

Java  Java program(.java) -javac-> .class files -java-> answer  
													JVM do the job

Object & Constructors
String s;
String s2=s;
s="Yow!"
s2="Yow!" 

s2=new String(s) 有五步操作
(1)look where s points
(2)follows reference to string object
(3)reads string 
(4)consturct new string w/copy of character
(5)make s2 reference new String

Methods
s2=s.toUppercase();

I/O class & object
Object in System class for interacting with a user
System.out is a Printstream object that output to the screen
System.in is an Inputstream object that reads from the keyboard 这里其实是指reference

To use Java libraries, other than java.lang, we "import" them 
java.io includes InputStreamReaders, BufferedReader, etc .

2.defining classes

unix/vim help session  真滴羡慕ucb的学生
Fields: variable stored in objects  
		aka instance variavle 

Defalut constructor takes no parameter, does no initializing
只写一个constructor defalut constructor gone

The "this" keywod 
amanda.introduce() implicitly pass an object (amanda) as a parameter called "this"
local variable 相比于 field varibale more priority(更具有优先级)

IMPORTANT: You cannot change the value of "this"
this.amanda; -> compiler error

the "static" keyword
static field: a single variable shared by a whole class of objects 
also called class variable

System.in & System.out are static fields

static method: does not implicitly pass an object as a parameter

IMPORTANT: In a static method,there is no "this"!!
referencing "this" ->compile-time-error


3.Types: conditions
byte: 8-bit integer -128-127
short: 16-bit -32768-32767
int: 32bit 
long: 64bit 
double: A 64-bit floating-point number 
float: 32-bit 
boolean: "true" or "false"
char: A Character23
	long x=43L;
	double & float values must have a decimal point.
	double y=18.0;
	float f=43.9f;

	char c='h';

					object type  		primitive types 
contains a    		reference			value
how defined	  		class definition	built into java
how initialized?	Constructors 		defalut
how used			Methods 			operators 

java.lang library :
		--Math class
		x=Math.abs(y);  x=Math.sqrt(y);
		--Interger class
		int x=Integer.parseInt("1998");
		--Double class
		double d=Double.parseDouble("3.14");

	Integer can be assigned to variables of larger types
		int i=43;
		long l=43;
		l=i ; 
		i=l;		//compiler error
		i=(int)l;

	Boolean values 
		"true" or "false"

CONDITIONALS
	if(boolValue){
	statements;
	}

	boolean pass=score>=75;

THE "return" KEYWORD

"return" causes a method to end immediately 
control returns to the calling method

return is means by which a function returns a value;

function: method declared to return a non-void type

Loops 
"while" loops 
public static boolean isPrime(int n){
	int divisor=2;
	while(divisor<n){
	if(n%divisor==0){
		return false;
	}
	divisor++;
	}
	return true;
}	

Iteration: a pass through the loop body
if n<=2, the loop body won't iterate ever once

"for" loop
for(initialize;condition;next){
	statements;
}		

Arrays 
An object storing a numbered list of variables 
Each is a primitive type or reference

char[]c; //reference to array(any length) of characters
c=new char[4];
c[0]='b';
c[3]='e';
c[4]='s'; //run-time error

Field "c.length"

Primes Revisited
Sieve of Eratosthenes

public static void printPrimes(int n){
	boolean []prime= new boolean[n+1];
	for(int i=2;i<=n;i++){
	prime[i]=true; //prime until proven composite
	}
	
	for(int divisor=2;divisor*divisor<=n;divisor++){
	if(prime[divisor]){
		for(int i=2*divisor;i<=n;i=i+divisor){
		prime[i]=false;
		}
	}
	}
}

Muti-dimensional Arrays
2D array: Array of reference to arrays

Pascal's Triangle  

Loop & arryas II
Aytimatic Array Construction
int [][]table=new int[x][y];

Initializers: 
	Human[]b={amanda,rish,new Human{"pdob"}};

int[]a,b,c; //all reference arrays
int a [],b,c[][]; // a is 1D;c is 2D;b is not array
int [] a, b[];  // a is 1D; b is 2D;

int []b[]= new int [3][];
int []b[]=new int [][3];  compile error

when you construct array of objects, 
java does not construct the objects 

main() parameter
List of command-line arguments

"do" loops

do{
	s=keybd.readLine();
	process(s);
}while(s.length>0)

s=keybd.readLine();
while(s.length()>0){
	process(s);				disadvantage:如果duplicate code有几百行就gg了
	s=keybd.readLine();
}

while(true){
	s=keybd.readLine();
	if(s.length()==0){
	break;					disadvantage : illegial 
	}	
	process(s);
}


"go to" is harmful ?

continue
(1)only applies to loops
(2)jumps to end of loop body but another iteration commerence if loop condition satisfied

CONSTANTS
"final" keyword: value that can never be changed
bad: if(month==2) 
good: public static int February=2;
	 if(month==February)

for any array x, "x.length" is a "final" field	

hw2错点：
静态方法不能调用非静态方法！！！ 

Lists  	Array-based lists
Advantage: very fast access of each item
2 disadvantage: 
 			（1)insert item at beginning or middle 
 				takes time proportional to length of array
 			 (2) array has a fixed length 

 LINKED LISTS   (a recursive date type)
 Make up of nodes. Each node has:
 (1)an item
 (2)a reference to next node in list

 public class ListNode {
 	public int item;
 	public ListNode next;
 }

 l1.next=l2;
 l2.next=l3;
 l3.next=null;

 public ListNode(int i, Listnode n){
 	item=i;
 	next=n;

 }
 public ListNode(int i){
 	item=i;
 	next=null;
 }

 ListNode l1=new ListNode(7,new ListNode(0,new ListNode(7)));

 Linked Lists vs array lists

 advantage of linked lists
 Inserting item into middle of linked list takes constant time
 if you have a ref to previous node 

List can keep growing out until memory runs out

Insert a new item:
public void insertAfter(int item){
	next=new ListNode (item,next);  //可以画一个图理解 注意里面的两个next是不一样的
}

disadvantage: Finding  nth item of a linkedlist
		start at head, walk n-1 nodes.

List Of Objects  reference any object

public class  SListNode {		s->singlelinkedlist
	public object item;
	public SlistNode next;
}

A List class
problem with SListNodes:
(1)Insert new item at beginning of list:  x=new SListNode("soop",x);
(2) how do you represent an empty list?
x=null; x.insertAfter(item) //run-time error

solution: separate SList class maintain the head of the list

public class SList{
	private SListNode head;
	private int size;
	public SList(){
	head==null;
	size=0;
	}
	public void insertFront(Object item){
		head=new SListNode(item,head);
		size++;
	}
}

The "public" and "private" keywords
private method or field: invisible & inaccessible to other classes
why????

(1)to prevent data from being corrupted by other classes
(2)you can improve the implementation without causing other classes to fail

The interface of a class: prototypes for public methods  ->java code
			plus description of their behaviors: plain English

Abstract Data Type (ADT): A class with well-defined interface, but implementation detail are hidden from other classes

Invariant:  A fact about a data strucure that is always true
			"A Date object always stores a valid date"
		Enforced by allowing access only through method calls

Not all classed are ADTs! some classes are data storage units, no invartants;field can be public 

The SList ADT
another advantage of SList class: it enforces 2 invariants;
(1) "size" is always correct
(2)A list is never circularly linked, 
Both goals accomplish because only SList methods can change the lists.
	SList ensure this:
	(1)The fields of SList(head & size) are "private".
	(2)No method of SList returns an SListNode .

DOUBLY-LINKED LISTS

Inserting/deleting at front of list is easy.
						end of lists takes a long time;

class DlistNode{
	Object item;
	DListNode next;
	DListNode prev;
}

class DList{
	private DListNode head;
	private DListNode tail;
	long size;
}

insert & delete items at both ends in constant running time

Removes the tail node (at list 2 items in DList):
	tail.prev.next=null;
	tail=tail.prev;

Sentinel: A special node that does not represent an item.

DList invariants (with sentinel)：
(1)for any DList d, d.head!=null
(2)For any DList x, x.prev!=null;
(3) "  "  " " , x.next!=null;
(4)"	" "	", if x.next==y,then y.prev==x;
(5) "	" "	", if x.prev==y,then y.next==x;
(6) A DLists "size" variable is DListNodes, not couting sentinel ,accessible from sentinel by sequence of "next" s .

public long size(){
	
}
Empty DList: Sentinel prev & next field points to itself

public void removeBack(){
	if (head.prev!=head){
	head.prev=head.prev.prev;
	head.prev.next=head;
	size++;
	}
}


The stack and the heap

the heap stores all object; include all arrays & class variables
the stack stores the local variable ,including parameter
when a method is called, java creates a stack frame (aka activation record);
stores the parameters & local variables
stack of stack frames 

gc affect the heap only

when a method finished, its stack frame is erased.
Method "Thread.dumpStack()" for debugging

Parameter passing 
Java passes all parameter by value: copied 

class IntBox{
	static void doNothing(int x){
	x=2;
	}
}

int a=1;
doNothing(a);

when parameter is a reference, the reference is copied, but the object is shared.

Common programming error

static void badSet4(IntBox ib){
	ib=new IntBox();
	ib.i=4;
}

Binary Search 
Searches a sorted array.
If we find "findme", return its array index;
otherwise,return faliure.

Recursion base cases:
(1)findMe==middle element: return its index
(2)subarray of length zero: return failure

Monday: President's Day
no lecture/office hours/discussion sections

INHERENTENCE

public class TailList extends SList{
	// "head" & "size" inherited from SList
	private SListNode tail;

}

TailList is subclass of SList
SList is the superclass ot TailList
A subclass can modify a superclass 3 ways
(1)It can declare new fields
(2)"	" "	" "	"	 new methods
(3)" " override old methods with new implementations

public void insertEnd(Object obj){
	//you solution to lab3
}
isEmpty(), length(), nth(), toString() are inherited from SList

Inheritance & construnctors 
Java execute TailList constructor before it executes any code.

public TailList(){
	// SList()  set size=0, head=null;
	tail=null;
}

public TailList(int x){
	super(x);  <- must be first statement in constructor
	tail=null;
}

Invoking Overriden methods 
public void insertFront(Object obj){
	super.insertFront(obj);
	if(size==1){
	tail=head;
	}
}

The "protected" keyword

public class SList{
	protected SListNode head;
	protected int size;
}

"protected" field is visible to declaring class & all its subclass but no others.
"private" fields aren't visible to subclass

Class Hierarchies 
				Object  
			String   worker
		student  ta 	professor

Dynamic Method Lookup
		Every TailList is an SList!!!
	SList s= new TailList();
	TailList t=new SList();  // Compile-time error!

Static type: the type of a variable
dnamic type: the class of the object the variable reference

when we invoke overridden method, Java calls methods for ojbect dynamic type, regardless of static type 

SList s=new TailList();
s.insertEnd(obj); //calls TailList.insertEnd();
s=new SList();
S.insertEnd(obj); 	//calls SList.insertEnd();

WHY DYNAMIC METHOD LOOKUP MATTERS
Method that sorts an SList using only SList method calls
Method that sorts an TailList too.

Subtltties of Inheritance
(1) new method in TailList--eatTail();
		TailList t=new TailList();
		t.eatTail();

		SList s=new TailList();
		s.eatTail(); 	//compile-time error
Why? Not every sList has an "eatTail()" method.
so Java can't use dynamic method lookup on s.

(2) SList s;
	TailList t= new TailList();
	s=t;
	t=s;		//compile-time error
	t=(TailList) s;

	s=new SList();
	t=(TailList)s;	//runtime error : classcastException

	int x=t.nth(1).intvalue();	//compile-time error
	int y= ((Integer)t.nth(1)).intValue();

(3) "instanceof" operator tells you whether object is of specfic class.
	
	if(s instanceof TailList){
		+=(TailList) s;
	}
return false is s is null or does not reference to a TailList
		true if s reference a TailList or subclass

equals() every class has an equals() method.
Default: inherit Object.euqals()
		r1.equals(r2) same as "r1==r2"
		run-time error if r1 is null

Many classes override equals() to compare content.
e.g Integer 
	i1==i2 false ;
	i1.equals(i2) true;

	i2==i3 true   ;
	i2.equals(i3) true;

Four degrees of quality: 
(1) reference equality, ==
(2) Shallow structural equality :  fields are ==
(3) deep structural equality : fields are .equals();
(4) logical equality 
	
	"set" objects are "equals" if they contain some elements 
	(even in different orders)

	Fractions 1/3 and 2/6 are "equals".
equals() may  test any of these 

public class SList{
	public boolean equals(Ojbect other){ not SList!!! signature must be the same as Object equals

	if(!(other) instanceof SList){
	return false;
	}
	SList o=(SList) other;
	if(size!=o.size){
	return false;
	}
	SListNode n1=head;
	SLsitNode n2=o.head;
	while(n1!=null){
	if(!n1.item.equals(n2.item)){
		return false;
	}
	n1=n1.next;
	n2=n2.next;
	}
	return true;
	}
}

"for each" Loops 
Iterate through array elements
	int []array={7,12,3,8,4,9};
	for(int i:array){
	System.out.print(i+"");
	}


TESTING 

(1) Modular Testing   	
	Test driver & stub 
	a:test driver call the code, check results
	b stubs: bits of code called by the code being tested

(2)Integration Testing 
	testing all components together

	define interfaces well
	learn to use a debugger.

(3)	result verfication 
	a: data structure integrity checkers
	Inspect a datastructure & verify that all invariants are satisfied.

	b: algorithms result checkers

assertion: code that tests an invariant or a result.
	assert x==3;
	aserrt list.size==list.countLength();
			"wrong SList size" + list.size;
	turn them on: java -ea 
	turn them  off:	 java -da  (greater speed)


ABSTRACT CLASSES
a class whose sole purpose is to be extended 
public abstract class List{
	protected int size;
	public int length(){
	return size;					//ADT(abstract data type)
	}
	public abstract void insertFront(Object item);
}

List myList;
myList =new List(); // compile-time error
Abstract method lacks an impletation 
public class SList extends List{
	//inherits "size"
	protected SListNode head;
	//inherits "length()"

	public void insertEnd(Object item){
		head=new SListNode(item,head);
		size++;
	}
}

A-non-abstract class may never 
 contain an asbstract method
 inherit one without providing an implementation

 List myList=new SList();
 myList.insertFront(obj);  compiles because everyList has an insertFront method
 myList.head =   //compile-time error( not every List has a "head" field)

 ((SList)myList).head=  //this complie and myList is still List static type while the expression
 								((SList)myList) is SList static type

 An abstract class lets you define an interface for multiple class to share,
 without defining any of them yet.

one List sorter can sort every kind of List 

public void listSort(List l){
	
}

subclass: SLsit,DList,tailList
TimeList 
TransanctionList

JAVA INTERFACE

"interface" : public field method prototype & behaviors 

"Java interface":  "interface" keyword. 

Java interface is like abstract class. 2 differences
(1) A class inherit from only one class
	can "implement" (inherit from ) many Java interfaces 
(2) A java interface cannot 
	implement any methods 
	include any field except "final static" constants
	only contains method protoytpes & constants

public interface Nokeable{
	public void nuke();  //assumed abstract
}

public interface Comparable { // in java.lang
	public int compareTo(Object o);
}

public class SList extends List implement Nukeable, Comparable {
	pulibc void nuke(){
		head=null;
		size=0;
	}

	public int compareTo(Object o){
		[return a number <0 if this<o,
		return 0 if this.equals(o),
		return >0 if this>0  ];
	}
}

Nukeable n= new SList();
Comparable c= (Comparable)n;

Arrays class in java.util sorts arrays of comparable objects

public static void sort(Object[]a) 

A subinterface can have mmutiple superinterface.

public interface NokeAndComparable extends Nokeable,Comparable{};

JAVA PACKAGES 

package: collection of classes, Java interfaces, & packages 
			that trust each other.
3 benefits (1)packages can contain hidden class not visible outside package
			(2) classes can have fields & methods visible inside package only 
			(3) different package can have class same name

			java.awt.Frame  		photo.Frame

	Examples 
	(1) java.io 
	(2) homework 4  uses "list" package containing DList & DListNode 
	(3) java.awt.image Model

Using Packages

Fully-qualified name
	java.lang.System.out.println(" ");
import java.io.File;	//Can now refer to File
import java.io.*; //everything in java.io

Every program imports java.lang.*;
java.awt.Frame.add(photo.Frame.canvas);

Building Packages 
/* list/SList.java */			/* list/SListNode.java */

package list;					package list;

public class SList{				class SListNode{
	SListNode head;
	int size;
}

"package" protection 
between "private" and "protected" 

A class or variable w/package protection is visible to any class in same package,but not any 
thing outside the package (i.e. files oustside the directory).

HW4: DListNode class is public 

"prev" & "next" have package protetion, so application cannot corrupt DList ADT.

public class must be declared in file named after class.
"package" classes can appear in any  . java file

Compiling and running must be done from ousside package
	javac -g list/SList.java 
	java list.sList


"public "
"protected"
"default"(package)
private	

ITERATORS 

public interface Iterator {
	boolean hasNext();
	Object next();
	void remove(); //optional
}

An Iterator is like a boomark.

can have many Iterators in some data structure

Calling next() nth time return nth item in sequence.
subsequent calls to next() throws an exception.
hasNext():true iff more items to return 

public interface Iterable {
	Iterator iterator();

}

DS.iterate()   constructs a DSIteraotr for DS.  

"for each" loop iterates over item in data structure 

for(Object o:l) {   // l-> SList implements Iterable
	System.out.println(o);
}

equivalent to:

for(Iterator i=l.iterator();i.hasNext()){
	Object o=i.next();
	System.out.println(o);
}

EXCEPTION

Run-time error:Java "throw an exception"
(Exception object).  Prevent the error by "catching" the Exception.
purpose: Copying with Errors
try{
	f=new FileInputStream("cs61b/pj2.solution");
	i=f.read();
}catch(FileNotFoundException e1){	e1-> variable declaration
	System.out.println(e1);		Exception handlers
}
	catch(IOException e2){	both e1 and e2 are subclass of Exception
	f.close();					
	}

(a) executes the code inside "try" clause.
(b) if "try" code executes normally skip "catch" classes.
(c) if "try" code throws an exception; do not finish the "try" code.
(d) Jump to first "catch" clause that matches exception;
	executes.		"match":exception object thrown is same class/subclass of the type in "catch" clauses

Purpose#2 : Escapsing a Slinking ship

throw your own exception 

public class ParseException extends Exception {}
				distinguishable from other types of exceptions

public ParseTree parseExpression()throws ParseException{
	[loops]									required!!
	if(something wrong){
		throw new ParseException();
	}									
}				

Different from "return"?
1.do not return anything
2.an exception can propagate several stack frames down the stack .

public ParseTree parse()throw ParseException,DumbCodeException{
	[loops and code]
	p=parseExpression();
	[more code]
}

public void compile(){
	ParseTree p;
	try{
	p=parse();
	p.toByteCode();
	}catch(ParseException e1){

	}
	catch(DumbCodeException e2){

	}
}


Checked and unchecked Throwables

											Throwable
							excpetion 											error
	IOException						RunTimeException					assertionError		virtualMachineError
			    		classcastException					NullPointerExcetpion				outofMemoryError

catching an error is rarely appropriate

unchecked Throwables do not require "throws" clause
All exceptions except RunTimeException are checked

when a methods calls a method taht can throw a checekedexception
(1)it can catch the exception the exception,or 
(2)it throws same exception itself.

the finally keyword

f=new FileInputStream("filename");
try{
	statement x;
	return 1;
}catch(IOException e){
	e.printStackTrace();	<- when exception is constructed,i taks a snapshot of stack
	return 2;
}finally {
	f.close();
}

if "try" statement begins, the "finally" clause will excute at the end, no matter what!

It statement x causes no exception-> "finally" clause executed, 1 returnred.

If statement causes IOException -> "catch"clause excutes,then "finally" clauses 2 return

If statement causes some other exception -> "finally" "excutes",then exception continues down the stack

Exception throw in "catch" clauses terminate the "catch" clauses, execute "finally",exception continues down stack

Exception throw in "finally" clause: replace old exception, "finally" clause & method end

Exception constructors

Convention: Most Throwables have 2 constructors

class MyException extends Exception {
	pulibc MyException (){super();}
	public MyException(String s){super(s);}	error message
}

error message

printed if it propagates out of main();
can be read by Throwable.getMessage().

Generics 

declare general class that produces special object
SList for String, SList for Integers, only SList class
SList takes a type parameter. 
class SListNode<T> {
	T item=;
	SListNode<T> next;

	SListNode(T i, SListNode<T> n){
		item=i;
		next=n;
	}
}
public class SList<T>{	<- T is formal type parameter
	SListNode<T> head;
	public void insertFront(T item){
	head=new SListNode<T>(item,head);

	}
}

create an SList of Strings:
	SList<String> l=new SList<String> ();		<-String is an actully tpye parameter
	l.insertFront("hello");
	String s= l.front().item();

Advantages: Compiler ensures at compile time that nothing but strings enters your SList<String> . 
Easier to debug than ClassCastExceptions much later!
in java Generic is only for Object 

Field SHADOWING

field can be "shaddowed" in subclass 
different from overrding .

choice at methods dictated by dynamic type
choice of fields dictated by static type

class super{				class Sub extends super{
									int x=4;	
	int x=2;						inf (){
									return 4;	
	int f(){					}
	return 2;
	}
}
	
Sub sub=new Sub();
Super supe=sub;
int i;
i=supe.x;		//2
i=sub.x;		//4
i=((super)sub).x //2
i=((sub)).x;  //4

Shadowing is a nuisance 

static methods follow same shadowing rules as fields.

"final" methods & classes 

"final" method-> cannot be overridden 
"final" class -> cannot be be extend 



Game Tree Search  Tic Tac Toe  google it!

assume both opponents are infinitely intelligent
Each grid is assigned a numerical score that indicateds how optimistim we are about winning 
1:computer is guaranteed a win.
-1:opponents guaranteed a win.
0:perfect players will draw 

Score a grid? suppose computer is X.
3 X's in a row :1 
3 O's in a row :-1
No empty quares, nobody has won: 0

Any other grid : minimax algorithm

(1)consider each possible move; determine child grid.
(2)score each child grid by calling minimax recursively
(3)assign a score to parent grid

computer's turn "choose move that yields maxmum score".

opponets's turn "choose move that yield minmun score"

public Best chooseMove(boolean side){
	Best myBest=new Best();		//My best move
	Best reply;				//opponent's best reply 
	if(this grid is full or has a win){
	return a best with the grid's socre,no move;
	}
	if(side==COMPUTER){
	myBest.score=-1;
	}else{
	myBset.socre==1;
	}
	myBest.move=any legal move; // make sure more is always initialized 
	for(each legal move m){
		perform move m;
		reply =chooseMove(!side); //recursive minimax an children
		undo move m;	//reverse "this" grid
		if((side==COMPUTER&&reply.score>myBestscore)||(side==HUMAN&&reply.score<myBest.score)){
			myBest.move=m;
			myBest.score=reply.score;
		}
	}
	return myBest;
}

Each grid in game tree represtent are invovation of chooseMove();

simple prunning 
	if a player discovers a guranteed winning move 
	there's no reason to search for a better move .

Alpha-beta Pruning 

Computer has dicovered a move (A) that guarantees a draw;
is investigating an alternative move(B).
Discover that if opponents moves X in response,the opponents can force a draw,
the opponent can force a draw.
stop investigating B

∂: a score that computer knows it can achieve 
ß:a score that opponent knows it can achieve

if ß becomes <= ∂, further investigation of current grid is useless

ENCAPSULATATION
Module:A set of methods that work together to perfrom some task.

A module is encapsulated if its implementation is hidden, & it can be accesssed only through a documentted interface.

ADT: Encapsulated date structure. 
not all modules are ADTS.

Algorithms (list sorters) & applications (netword routing software) can be encapsulated

public class ListManager {
	
	list.head.next=list.head.next.next;	// violation of data hidding 
}

This kind of bug is one of the most difficult to find & fix 

Application

  |interface|

  |	module or		|
  |	Abstract Data type		|
  |			|
  |			|

 Data can only go in & out through the interface.

 why encapsulation is your friend ?

 (1)the implementation is independent of the functionality
 	->with the interface documentation, you can implement a new version independently.
 	->New , better implementation can replace old one.
 (2)Prevents everyone from corrupting a modules internal data.
 (3)ADTS can guarantee their invariants are preserved 
 (4)Teamwork. Once you've define interfaces, each programmer can independtly implement a module.
 (5) Documentation & maintainability. 
 (6) pj2 doesn't work?? Easier to point the blame
 (7) An interface is a CONTRACT between module writers, specifying exactly how they will communicate

 Enforcing encapsulation
 Many language: self-discipline.
 Java : package & "private", package, & "protected "

 not always enough, e.g. many modules in some package.

 pj2: could put all modules in "player" package.

 One way to selef-discipline: different team member work on each module. Neither team member reveals code to others. 

 project 2 
 Document interface in GRADER before you start programming. Allows you to work as a team.

 		Machine Player

 	game tree search module 

evalution function 		
						network identifier

Modules must be independent and communicate through simple interfaces. 

A module is organized around functionality it provides.
A class is organized around a data storage unit.

A module can be made up of several classes;
a class can be made up of several moduels. 
	Module might implement data structure made of several classes 
e.g. List=list object +node objects.

class can support many independent operations.
game tree search; evaluation function; network id.
all operate on game board .

A module may include many methods or few.
A package may contain are modue or many.

Project 2 documentation: 
-List the modules.  
-For each modules, specify its interface. 
o Prototype(s) for methods available for external callers:
o Comment that describes behavior from external point of view.

o Describe every parameter & return value.

complete & unamiguous 
interfaces appears in both GRADER and code.

ENCAPSULATED LISTS (a case study)
hw 3,4,5 : Three different linked lists;

hw3 lists: query every item : O(n^2) time. (use nth(i),takes time ∂ i)
hw 4,5: Application can hold a node.
		Query every time in O(n) time 

hw 5 SList & DList are well-encapsulated 
hw 4 DList had flaws. 

(1)what if l.remove(n); -but node n is a different list than l!
	hw4: "size" field of wrong list is updated!
	fix? 
	ADT interface fix: remove(), insertAfter(),etc. should update the right list's "size"!
	implementation fix : every node keeps a reference to list that controls it .
	hw5: "mylist" 
(2)should insertAfter(),remove(), etc. be methods of List or ListNode 

	ADT interface fix:
		 List    	


		Implementation fix: Each node has "myList" field, 
							update correct list's "size". 
(3)what if l.remove(n), l.insertAfter(i,n) 	


calling remove(n) twice on same node also corrupts "size"
	fix?

	ADT interface fix: After n.remove(n), n is  "invalid", any attempts to use n throws exception

Implementation fix:  n.remove()-> n.myList set to null. (mark n invalid) 						


(4) what if we walk off end of list? (using next());

ADT interface answer: 	
		hw4 :return null.
		hw5 : return invalied node .
		 provide some consistency: tail.next() & remove()give some result.
		 n.next.item() -> hw5 it throws InvalidNodeException 
		 				hw4 it throws NullPointerException 
		 				Eliminates ambiguity .

		 Implements that answer:  any sentinel is an invalid node.

(5) How do we access an item ?
	ADT interface answer: 
		hw4: Node's "item" is public .
		hw5: ""   is protected, application must use item() & setitem(). why??
		Application can't store items in deleted nodes or sentinels. 

	ADTs should never do more than the documentation says 
			 

ASYPOTOITC ANALYSIS

Inventory: 

	10000ms to read inventory from disk.
	10ms to process each transaction.
	n transcations takes (10,000+10n)ms.	more important if n is large

	Big- On Notation (upper bounds)

	Let n be size of program's input.
	Let T(n) be function. e.g. running time in ms.
	Let f(n) be another function - prefably simple 

	T(n) 

	How big is "big"? big enough to make T(n) fit under c t(n)
	How large is c? 

EXAMPLE: Inventory 

T(n)=10,000+10n

Try out f(n)=n;  pick c=20.

FORMALLY :  O(f(n)) is the SET of ALL function T(n) that satisfy: 
	There exist positive constatns c&N such that 
	for all n>=N, T(n)<=cf(n). 

O(n)is subset O(n^2)

EXAMPLES:
	(1) 1,000,000 n is subset of O(n) proof: set c=1,000,000,000, N=0;
	Big-O notation doesn't care about (most) constant factors.

	O(2n)=O(n)=O(1000,000,000n)

	(2) big-o specifies UPPER bound only.

(3) n^3+n^2+n O(n^3)  proof: Set c=3 ,N=1;

	Big-o notation is usually used to indicate dominant  (largest) term

Table of Important Big-O Sets 
From smallest to largest :  
						function   common name
						O(1) 		constant 
						O(logn)		logarithmic 
						O((log^2)n)  log-squared
						o(√n) 		root-n
						O(n)		linear
						O(nlogn)	
						O(n^2)		quadratic 
						O(n^3)		cubic
						O(n^4)		quartic
						O(2^n)		exponential

Algorithms running in O(nlogn)time or faster considered efficient !  n^ time or more : useless

Logarithms: 4.1.2 & 4.1.7 of G & T


Warnings 

(1) Fallacious proof : 
(2) Big-o notation does not say what the function mean 
	binary search on an arrays 
	worst-case running time O(logn) 
	best-case running time O(1)
	memory-use 

(3) e^(3n) 
(4) Big-O notation does not tell whole story 
	T(n)=nlogn
	
DICTIONARIES

Two-letter words & definitions.
word is the key that addresses the definition: 
26*26=676 possible words

To insert a Definition into dictionary:
	function hashcode() maps each word (key) to 
	integer 0....675. Index into array; store Definition there.

public class Word{
	public static final int LETTER =26;
							WORDS=LETTER* LETTER;
	private String word;

	public int hashCode(){
			return LETTER * (word.charAt(0)-'a')+(word.charAt(1)-'a');
	}
 }	

public class WordDictionary{
	private Definition []defTable=new Definition[Word.WORDS];

	public void insert(Word w,Definition d){
		defTable[w.hashCode()]=d;
	}

	Definition find(Word w){
	 return defTable[w.hashCode()];
	}
}


Hash Tables (most common implementation of dictionaries)
n: number of keys (words).
Table of N buckets, N a bit larger than n.

Hash table maps huge set of possible keys into N buckets 

by applying a compression function - to each hash code.

h(hashCode)=hashCode mod N.   // hashCode is often negative 
					
					not exactly the same as % .

Problem: Collisions: Several keys hash to same bucket.
solution: chainning. Each buckets references a linked list of Definitions, called a chain.
problem:：Which Definition for which Word?
Soulution: Each listnode store Word & Definition together. 
			
defTable 
		3 operations: 

	public Entry insert(key,value){
		compute key's hash code .
		compress it to determine bucket.
		Insert the entry into th bucket's list
	} 				 

	public Entry find(key){
		Hash the key
		search list for entry with the given key
		if we find, return entry;  	otherwise, return null.
	}

	public Entry remove(key){
		hash the key
		search the list.
		Remove if from the list if found.
		return entry or null.
	}


2 entries w/same key?
	
	(1)G & T: insert both, find() arbiraily returns one.
		findAll()

	(2)Replace old value w/new . only one entry w/given key exists.

Load factor of hash table is n/N.

if load factor low 
		& hash code & compression fn are "good"
		& no duplicate keys stored,
		then the chains are short & each operation takes O(1) time.

If load factor too large (n>>N) ,O(n) time.


hash code & compreesion functions 
			key-> hash code -> [0,N-1]  N:the number of buckets

Ideal: Map each key to random bucket 

	Bad compression function: 
		suppose key are ints.  hashCode(i)=i. 

	Compression function: h(hashCode), hashCode mod N, 
	N=10,000 buckets

	suppose keys are divisible by 4.

	Three quarters of buckets never used!!!
	Same compression fn better if N is prime.

better:  h(hashCode)=((a*hashCode+b)) mod p) mod N 
		
		a,b,p:positive Integers,
		p: large prime,p>>N

	Now, N(buckets) does not need to be prime. 

	Hash Codes 

Good hash code for Strings: 
	private static int hashCode(String  key){
		int hashVal=0;
		for(int i=0;i<key.length();i++){
			hashVal=(127*hashVal+key.charAt(i))%16908799;		mix up the bits
		}
		return hashVal;
	}

	why does x mod prime mix up bits?

	Bad hash codes on Words.
	(1)sum ASCII values of characters.
			anagrams like "pat","tap","apt" collide
		Raraly exceeds 2,000  
	(2)First 3 letter of a word, with 26^3 buckets.
	   Bucket zzq gets much less use than "pre" 
	(3)suppose prime modules is 127.
	   Last char rules!!
	   Mutiplier & modulues must havs no common factors

Resizing Hash Tables 

	If load factor n/N gets too big, we lose constant time performance 
	enlarge hash table when load factor is about 0.75.
	Allocate new array at least twice as long.
	Walk through entires in old array, rehash them into new .
Option: Shrink hash tables (e.g. when n/N<0.25) to free memory 

Average running time over long run is still O(1) per operation.

Transposition Tables : Speed Game Trees 
	Some grids reachable through many different sequences of moves .

	evaluate many times.
	Maintain hash tables of grids.
	Called transportation table. 
		key is the grid   value is its score 

Minimax algorithms  checks if grid is in transposition tables.

	yes: return scores.
	No: evaluate score (by minimax) & store in hash table.

Empty the table after making a move! 
	

Stacks
Operations: 
	"push" new item onto top of stack.
	"push" top item off stack.
	examine "top" item.


All methods run in O(1)time
easily implemented as single-linked list 

sample application: verifying matched parentheses 
{[({[]})]()}

alg: scan through string, char by char .

	lefty 
	righty pop its counterpart from stack, chech that they match.
	mismatch or null returned, or stack not empty at end of string -> parentheses not properly matched .
	这个字符匹配问题我感觉教授就讲的非常好！！！

Queues 
	Operations:
	"enqueue" item at back of queue
	"dequeue" tiem at front of queue
	examine "front" item.

ab -> dequeue ->b enqueue(c)->bc

Sample application : Printer queues.

All methods run in O(1)time
easily implemented as singly-linked list with tail pointer.

DEQUES
  Double-Ended Queue 
  you can insert & remove items at both ends 
  Use a doubley-linked list.



Ω(n)means at least good


ROOTED TREES

Tree: set of nodes & edge that connect them. 
 	exactly one path betweem only two nodes
 		Path: A sequece of one or more nodes, each consecutive pair connected by an edge.

 	Rooted tree: one distinguished node is root.
 Every node c, exception root, has a one parent p 
 	the first on the path from c to the root.
 	c is p's child.
 	root has no parent
 	A node can have any # of children 
 	Leaf:node with no children .
 	Internal node: no-leaf node
 	Siblings: Node with same parent.
 	Ancestors of d: nodes on path from d to root, including d,d's parent, d's granny, ...., root .
 	If d is ancesotr of d, then d is a descendant of a.
 	Length of path: # of edges in path.
 	Depth of node n: length of path from n to root.
 	Depth of the root is zero!
 	Height of node n : length of path from n to its deepest descendant.
 		Height of a leaf is zero!!
 	Height of a tree = height of root.
 	subtree rooted at n: tree formed by n & its descendants
 	Binary tree: no node has >2 children & every child is a left child or a right child, even if its the only child

 	Representaing Rooted Trees 

 G & T:  Each node stores 3 references: 
 	item    parent  children,stroed in list.

 	Option 2:   Sibling treenode are directly linked 

 		class SibTreeNode {
 		Object item;
 		SibTreeNode parent;
 		SibTreeNode firstChild;
 		SibTreeNode nextSibling;
 		}

 		class SibTree{
 			SibTreeNode root;
 			int size;
 		}

 		Tree Traversals 
 		traversal: a manner of visiting each node in a tree once .
 		preorder traversal: visit each node before recursive visiting its children,left to right. Root visited first.
 		class SibTreeNode {
 			public void preorder (){
 				This.visit();
 				if(firstchild!=null){
 				firstchild.preorder();
 				}
 				if(nextSibling !=null){
 				nextSibling.preorder();
 				}
 			}
 		}

 		each node visited/preorder() only once, so preorder takes O(n) time ,where n is # of treeNodes.

 		~jrs/61b
 			hw 
 			  hw1
 			  hw2
 			index.hmtl
 			lab
 				lab1
 				lab2
 			lec 
 				o1
 				o2
 				o3
 				o4

 		post-order	traversal:	recursively visit each node's children (left to right) before the node itself.

 		Natural way to sum total disk space.

 		Binary tree have inorder travsersal : recursively traverse root's left subtree(rooted at left child),
 			then root, then right sub tree.


 			Infix:   prefix:  postfix:

 		Level-order traversal: 	visit root , the all depth -1 node from (left to right),then all the depth-2 nodes, etc.
 		Not recursive. 
 		use a queue, which initially contains root.
 		repeat: 
 			dequeue a node
 			visit it 
 			enqueue its children(left to right).
 			until queue is empty.


 			PRIORITY QUEUES 
 			Entries: key & value. 
 			Define total order on the keys.	
 			Operations:
 				insert () adds entry to priorityqueue
 				min() returns entry w/minimun key 
 				removeMin() remove & returns """" .

 			Commonly used as "event gueues"in simulations.
 			Binary Heap: An Implementation of priority queues.
 			Complelte binary tree: Every row is full, except bottom row, which is filled from left to right.

 			Binary heap: complete birany tree whose entries satisfy heap-order property: no child has a key less than its parent's 
 			Every subtree of a binary heap is  bianry heap.

 			To store as arrays, map treeNodes to array indices with level numbering:
 			level-order traversal with root at index 1.
 				node i's children are 2i and 2i+1; partent is  floor[i/2].
 			Each treenode has 2 references: key , value.
 			
 			(1)Entry min();
 			return entry at root.

 			(2)Entry insert(Object k, Object v);
 			Let X be new entry (k,v).
 			Place x in bottom level tree, at first tree spot from left.
 			i.e. first tree location in array.
 			Entry bubbles up tree until heap-order property is satisfied.
 				while x's key < parent's key, swap x with parent;
 				repeat for x's new parant.

 			(3)Entry removeMin();
 				Remove entry at root; save it for return value.
 				Fill hole with last entry in tree, x.
 				Bubble x down the heap: 
 					while x>one or both children, swap x with its minimum children;
 					repeat 

 				Running Times:	
 					Binary Heap;Sorted List/Array   Unsorted List/Array 

 				insert ()takes O(1)time to compare x w/parent & swap
 				An n-node complete binary tree has height floor[logn]

 				Bottom-up heap construction 
 					Given bunch of entries; make a heap;
 				(4)void bottomUpHead();

 				Make complete tree of entries, in any order.
 				Work backward from last internal node to root.
 					(i.e. reverse order in array)
 					when visiting node, bubble its entry down (as in removeMin()).
 					

Binary search tree
Ordered dictionary:  keys have a total order,like a heap.
Quickly find entry w/min or max key.

An inorder traversal of a binary search tree visits nodes in sorted 

public Entry find(Object k){
	BinaryTreeNode node=root;
	while(node!=null){
		int comp=((Comparable)k).compareTo(node.entry.key());
		if(comp<0){
			node=node.left;
		}else if(comp>0){
			node=node.right;
		}else{
			return node.entry;
		}
	}
	return null;
}

1.How to find smallest key>=k or larget key<=k?
When searching down tree for a key k that not in the tree, we encounter both:
(1)node containing smallest key>k
(2)node containing smallest key<k


2.Entry first();
Entry last();

It tree is empty,return null;
Otherwise, start at root.
repeatedly go to left child until no left child ,return minimum key.

3.Entry insert(Object k,object v){
	Follow same path through tree as find();
	when reaches null reference, 
	replace null w/a new node with entry(k,v);
}

4.Entry remove(Object k);

	find a node n with key k;
	return null if k not in tree.
	if n has no children, detach it from its parent

	if n has one children, move n's child up to take n's place
	if n has two chlldren, let x be node in n's right subtree w/smalleest key
	remove x , x has no left child, is easily removed.
	replace n's entry with x's entry.

Running times


2-3-4 Trees
A perfectly balanced tree.
find, insert, remove take O(logn) worst-case

Every node has 2,3 or 4 children, except leaves, which are all at bottom level.

Each node sotre 1,2,3 or 3 entries.

	# of children is entries+1 or zero

G & T "bottom-up" 2-3-4 trees;
today: "top-bottom" 2-3-4 trees  Faster.

1.Entry find(Object k);
2.Entry insert(Object k,Object v);
	walks down tree in search of k.
	if it finds k, it proceeds to k's "left child" and continues.

	whenever insert() encounter a 3-key node, middle key is places in parent node.
	(Parent has at most 2 keys, always have room for a third)

3.Entry remove(Object k);
	Find key K.
	if it's in a leaf, remove key from leaf
	if it's internal node, replace it with etry with next higher key.
	remove()changes nodes as it walks down.
	Eliminate 1-key nodes(except root) so keys can be removed from a leaf without leaving it empty.

	(1)remove() encounter 1-key node(except root), try to steal a key from an adjacent sibling
					rotation
	(2) if no adjacent sibling has >1 key, steal key from parent
		parent(unless root) has >= 2keys.
					fusion
	(3)if parent is root and contains only one key, and sibling contains only key.
		sibling contains only one key, fuse all into 3-key node.
		the new root. 

Running time 

A 2-3-4 tree with height h has 2^h & 4^h leaves.
Total # of entries n>= 2^(h+1)-1

Time spent visiting node O(1).

find(),insert(),remove() worst-case times: O(logn).

Binary search trees :worst O(n)


GRAPHS 
	a graph G is a set of V of retices and a set of E of edges that connect vertices 

	G=(v,E)				T=(V,F)
	 ordered pair

2 types: directed & undirected 
	Digraph: every edge e is directed from some vertex v to some vertex w


	Undirected: e=(v,w) is an unordered pair. 
	
	(v,w)=(w,v)

	mutiple copies of an edge are forbidden.
	Digraph may contain both (v,w) & (w,v);

	self-edges(v,v);
	path: sequence of vertices with each adjacent pair connected by an edge. If graph is directed, edges must be aligned with direction of path.

	Length of path: # of edges.
		<4,5,6,3>: length 3.
		<2>:length O. 
		<2,2>: length 1
		<2,2,2>: length 2

	Strongly-connected: there is a path from every vertex to every other vertex.
		(Called connected in undirected graphs.)

	Degree of vertex: # of edge incident on vertex. 
	(self-edges count just once)!

	Digraph indegree: # of edges directed toward it .
			outdegree: # of edges         away it.

	Graph representations: 
	Adjacency matrix: |v|-by-|v| array of booleans.

	Planar graphs have O(|v|)edges.
	Graph is sparse if it has far fewer edges that maximum.

	Adjacency list: Each vertex v has a list edges out.

	Memory used 

	If vertices are consecutive ints, use array of lists to find any vertex's list on O(1) time.

	If vertices are objects ,use a hash table. key : vertex object  value:list

	Adjacency list is more space and time efficient for a sparse graph, less efficient for a complete graph

	graph Traversals 
	visit each vertex once.
	Depth-first search(DFS) searches graph as "deeply" as possible as early as possible. 
	If graph is tree, DFS performs preorder traversal.

	Breadth-first search (BFS) visit all vertices shoe distance from starting vertex is one, then two, & so on

	If graph is tree, BFS performs level-order traversal.
	Each vertex has a boolean field "visited" taht tells us if we have visited it before

	Assume a strongly connected graph
	When DFS visites a vertiex u. it chech every edge(u,v).
	if v not yet visited, DFS visites it recursively.

	public class Graph{
		public void dfs(Vetex u){
			u.visit();
			u.visited=true;
			for(each vertex v such (u,v)){
				if(!v.isited){
					dfs(v);
				}
			}
		}
	}


Graphs(continued)

	public void bfs(Vertex u){
		u.visit(null);
		u.visit=true;
		q=new Queue(u);
		q.enqueue(u);
		while(q is not empty){
			v.dequeue();
			for(each vertex w such that (v,w) is an edge in E){
				if(!w.visited){
				w.visit(v);
				w.visit=true;
				q.enqueue(w);
				}
			}
		}
	}

	public class vertex {
		protected Vertex parent;
		protected int depth;
		protected boolean visited;
		public void visti(Vertex origin){
			this.parent=origin;
			if(orogin==null){
				this.depth=0;
			}else{
				this.depth=origin.depth+1;
			}
		}
	}


	Find shortest path from any verte to start vertex by following parent pointers
	"depth" tells you length of that path.

	BFS runs in O(|v|+|E|) time w/adjacency list.

Weighted Graphs
	
	Each edge labeled with numerical weight. 
		Adjacency matrix: array of ints, doubles.
		Adjacency list: each listnode includes a weight.
		problems:
		 	(1)shortest path problem 
		 	 	BFS solves this if all edge weightes are 1.
		 	cs170 for nonuniotrm edge weights.
		 	
		 	(2)minimun spanning tree 
		 		Each vertex is outlet or source of electricity.
		 		Edges labeled with length of wire.
		 		Connect all nodes with shortest length of wire.

		 	Kruskal's Algorithm
		 	
		 	G=(V,E) undirected graph.
		 	A spanning tree  T=(v,F) of G is a graph w/same vertiecs as G, and |v|-1 edges
			of G that form a tree. 	

	If G is weighted, a minimum spanning tree T of G is a spanning tree whose total weight 
	(summed over all edges of T) is minimal. 

	1. create new graph T with same vertices as G, no edge (yet).
	2. Make a list of all edges in G. 
	3. sort edge by weight, least to greatest.
	4. Iterate through edges in sorted order.
		For each edge (u,w):

	4a.If u and w are not connected by path in T.
		add (u,w)to T.

	Never adds (u,w) if some path connects u&w, T is guarantee to be a tree(if G is connected)
		or a forest.

		G&T page 649: proof	

		O(|v|+|E|log|v|) time w/adjacency list

		怎么确定 4a步骤中判断环形呢？notes中说最简单的方法是在T中u点进行DFS，看看我们能否访问到v，但是这样比较慢
		在lecture 33 中会有更快的方法。

	Sorting 

	Insertion sort: 
		O(n^2) time 
		Invariant: S is sorted .
		Start with empty list S & unsorted list I of n items
		for(each item x in I ){
			insert x into S in sorted order.
		}

	If S is linked list, If S is array, insertion sort is a in-place sort

	If S is balanced search tree
			then running time is O(nlogn)

	Selection Sort 
	 Also guadratic time.  Invariant: S is sorted.
	 Start w/empty list S & unsorted I of n items
	 for(i=0;i<n;i++){
	 	x<- item in I  w/smallest key .
	 	remove X from I .
	 	append X to end of S. 
	 }			
	 whether S is array or linked list ,  feida(n^2) time ,even in best case!
	 In-place :

	 Heap Sort-> a kind of selection sort in which I is a heap.
	 start w/s & I  [same line]

	 toss all item in I onto heap h(ignoring heap-order property).
	 h.bottomUpHeap(); (take linear time)
	 for(i=0;i<n;i++){
	 	x=h.removeMin();
	 	append x to end of s
	 }

	 HeapSort runs in O(nlogn) time.

	 In place: Maintain heap backward at end of array.

	 Excellent for arrays, awkward for link lists.

	 Mergesort 
	 	merge 2 sorted list into one sorted list in linear time.
	 	Let Q1 & Q2 be 2 sorted queues. Let Q be empty queue.
	 	while(neither Q1 nor Q2 is empty){
	 		item1=Q1.front();
	 		item2=Q2.front();
	 		move smaller of item1 & item 2 from present queue to end of Q.

	 	}
	 	concatenate remaining non-empty queue(Q1 or Q2) to end of Q.

	 Mergesort is a recursive divide-and-conquer algorithm 
	 	start w/unsorted list I of n items.
	 	Break I into halves I1 & I2, having 
	 	Sort I1 recursively, yielding s1.
	 	Merge s1 & s2 into sorted list s.
	 	height:1+logn
	 	O(n) each level

	 Not an in place algorithm. 
	 
	 use extra array to temporarily hold result of merge.

	 QuickSort 
	 	recursive divide-and-conquer algorithms.

	 Fastest comparison-based sort for arrays
	 	 Theta(n^2) worst-case time
	 	 virtually always runs in O(nlogn) time.

	 Start w/list I of n items. 
	 choose pivot item v from I.
	 Partition I into two unsorted lists I1 and I2.
	 - I1 contains all items whose keys are smaller than v’s key.
	 - I2 contains all items whose keys are larger than v’s.
	 - Items with the same key as v can go into either list.
	 - The pivot v, however, does not go into either list.
	 Sort I1 recursively, yielding the sorted list S1.
	 Sort I2 recursively, yielding the sorted list S2.
	 Concatenate S1, v, and S2 together, yielding a sorted list S.
	 --------------------------- 
	 |4 | 7 | 1 | 5 | 9 | 3 | 0|
	 ---------------------------
	  Just like in mergesort, the tree has O(log n)
	levels.  Partitioning a list is a linear-time operation,
		so the total running time is O(n log n).

	Choosing a Pivot
    A respected, time-tested method is to randomly select an item from I to serve as pivot.
    With a random pivot, we can expect "on average" to obtain a 1/4 - 3/4 split; （G & T 11.2.1）

    Quicksort on Linked Lists
    Suppose we put all the items having the same key as v into the list I1

    Better: partition I into 3 lists
    I1,I2,Iv
    Iv contains pivot v & all item w/same key as pivot.

    concatenate s1,iv,s2 to yield S.

    Quicksort on Arrays
    	In-place 

    	Suppose we have an array a in which we want to sort the items starting at a[low] and ending at a[high].We choose a pivot v and move it out of the way by swapping it with the last item, a[high].

      i<- low-1  j<-high
      i&j sandwich item to be sorted 
      	Invariants:
      		All item at or left of index i have a key<=pivot
- 			All items at or right of index j have a key >= the pivot’s key.


      	items w/same key as pivot?
      	i & j stops when key=pivot
      	if all items have same key, half go into I1,half into I2, well-balanced recursion tree 
      	O(nlogn) time
      	G & T got this wrong!!


DISJOINT SETS
		
		No item is in more than one set.
		  The collection of disjoint sets is called a _partition_  
		  a _universe_ of items:is made up of all of the items that can be a member of a set

		  2 operations:
		  	union merges 2 sets into one
		  	find takes an item, tells us which set it is in.

List-Based Disjoint Sets and the Quick-Find Algorithm
	The obvious data structure for disjoint sets looks like this.
- 		Each set references a list of the items in that set.
- 		Each item references the set that contains it.	

	find: O(1)time
	union: slow .

Tree-Based Disjoint Sets and the Quick-Union Algorithm
	union: O(1)time
	find: slower 
	quick-union is faster overall than quick-find.
	Each set stored as a tree.
	Data structrues is a forest.
	Each item is initially root of its own tree.
	No child or sibling references .  Only parent references 

	True identity of each set is recorded at root	

	Union: make the root of one set be child of root of other set.

	"find" follows parent references from item to root of tree.

	cost proportionnal to item's depth.

Union-by-size：keeps items from getting too deep. At each root, record size of tree.
		make the smaller tree be  a subtree of the larger one.

Implementing Quick-Union with an Array
	
	Suppose the items are non-negative integers, numbered from zero

	Array records parent of each item.
	If item has no parent, record size of its tree as negative number -size



Path Compression
		public			


Naming Sets
	 maintain an additional array that maps root items to set names

	 often we only want to know if items X & Y are in same set.
	 run find(x),find(y) check if 2 roots are the same.

	 Running Time of Quick-Union
	 union: Theta(1);
	 find: Theta(logu) worst-case time, where u is # of unions.
	 		Average running time close to constant.
	 	A sequence of f finds & u unions takes Theta(u+∂(f+u,u))time worst case
	 	alpha is an extremely slowly-growing function known as the _inverse_
_Ackermann_function_.
		Never >4 for any values of f & u you'll ever use.

	 Hence, for all practical
purposes (but not on the Final Exam), you should think of quick-union as having
find operations that run, on average, in constant time.


SELECTION
	want to find the kth smallest key in a list	

Quickselect
	modify quicksort to perform selection for us

	Start with an unsorted list I of n input items.	
	Choose a pivot item v from I.
	Partition I into three unsorted lists I1, Iv, and I2.
	- I1 contains all items whose keys are smaller than v’s key.
- I2 contains all items whose keys are larger than v’s.
- Iv contains the pivot v.
- Items with the same key as v can go into any of the three lists.
A _comparison-based_sort_ is one in which all decisions are based on comparing
keys (generally done by "if" statements).  All actions taken by the sorting
algorithm are based on the results of a sequence of true/false questions.  All
of the sorting algorithms we have studied are comparison-based.
(In list-based quickselect, they go into Iv; in array-based quickselect,
    they go into I1 and I2, just like in array-based quicksort


A LOWER BOUND ON COMPARISON-BASED SORTING
		Suppose we have a scrambled array of n numbers, with each number from 1...n
	occurring once.  How many possible orders can the numbers be in?

		The answer is n!
		Each different order is called a _permutation_ of the numbers
		n!possible permutations

A _comparison-based_sort_ is one in which all decisions are based on comparing
keys (generally done by "if" statements)

A correct sorting algorithm must generate a _different_ sequence of true/false
answers for each different permutation of 1...n

If a sorting algorithm asks d true/false questions, it generates <= 2^d
different sequences of true/false answers

The algorithm spends Omega(d) time asking these d questions.

EVERY comparison-based sorting algorithm takes Omega(n log n) worst-case time.

LINEAR-TIME SORTING
	However, there are faster sorting algorithms that can make q-way decisions for
	large values of q, instead of true/false (2-way) decisions.  Some of these
	algorithms run in linear time.

Bucket Sort
		Bucket_sort_ works well when keys are distributed in a small range	, e.g. from
		0 to q - 1, and the number of items n is larger than, or nearly as large as, q.
		In other words, when q is in O(n).

	Bucket sort takes Theta(q + n) time in the best case and in the worst case.	
	It takes Theta(q) time to initialize the buckets in the beginning and to
concatenate them together in the end.  It takes Theta(n) time to put all the
items in their buckets.

A sort is stable if items with equal keys come out in the same order they went in
Bucket sort is stable.


Counting Sort

	items we sort are naked keys,no associated values .
	No queue.
	count of how many copies of each key

Counting Sort with Complete Items
	key plus associated value.
	Let x be input array of objects with keys.

	for(int i=0;i<x.length;i++){
		counts[x[i].key]++;
	}

	do a scan so counts[i] contains # of keys <i

	total=0;
	for(j=0;j<counts.length;j++){
		c=counts[j];
		counts[j]=total;
		total=total+c;
	}

	let y be output array. counts[i] tell us the first index of y to put item with key i .

	for(int i=0;i<x.length;i++){
		y[counts[x[i].key]]=x[i];
		counts[x[i].key]++;
	}

	Bucket sort and counting sort both take O(q + n) time.  If q is in O(n), then
    they take O(n) time.

    Array: counting sort faster
    Linked List: bucket sort is more natural .


Radix Sort:
	
	sort 1000 items in range 0..99,99 9,999.     	
	Provide q =10 buckets; sort on first digit only. 

	we could sort queue recursively on second digit 
	third digit and so on.

	clever idea: keep numbers  in one pile throughout sort;
		sort on last digit first, then next-to-last, etc.

	up to most significant digit .
	
	works because bucket sort & counting sort are stable.


	Faster if we sort 2 digit at a time (radix q=100) or 3 digits (radix q=1000).
	Computers: power-of-two radix like q=256.
	q= # if bucket =radix of digits we use as sort keys.

	Time:
		How many passes?


SPLAY TREES
	
	Balanced bianry search tree.
	All operations:  O(logn) Time on average;
				n is # of entries in tree.

	A single operation:  Theta(n) worst case.
	Any sequence of k ops, with initally empty & never > n items.

		takes O(klogn)time worst-case time.

	Fast access to entries accessed recently .
	
	Tree Rotations 	
		splay trees are kept balanced with rotations.

SPLAY TREE 
		Splay tree operations 

		1.entry find(Object k);
			begins like ordinary BST: walk down tree to entry with key k or dead end.
			Let x be node where search ended, whether it contains k or not .Splay X up the tree through a sequence of rotations, so X becomes root of the tree.

			3cases:
		2.	Entry min();
			 		max();
			 find entry with min/max key.
			 splay it to the root.

		3. Entry insert(Object k, Object v);
			Insert new entry (k,v).
			Splay new node to root.

		4.	Entry remove(Object k);
			An entry haveing key k is removed from tree ,as with oridinary BST 
				If X be the node removed from the tree.
				Splay X's parent to the root.
				Recall that the node containing k is removed if it has zero or
			one children.  If it has two children, the node with the next higher key is
				removed instead 		

	Rdandomized Algorithms

			that make decisions based on rolls of the dice.Helps keep running time low.

			Quicksort,quickselect, hash tables w/random hashcode.	

			Expectation
				x() filps a coin 
					heads:one second to execute.
					tails:3 seconds to excutes.
				Let X be running time of one call to x ().
				with probability 0.5 X is 1
				with probability 0.5 X is 3.

				X -> random variable 
				Expected value of X 
					E[x] = 0.5 * 1 + 0.5 * 3 = 2 seconds expected time 
					x();
					X();

				What is the expected total time E[T]?
				Linearity of expectiation:
					E[X+Y]=E[X]+E[Y].

Hash Table 
	Random hash code maps each possible key to a randomly chosen bucket, but a key's random hashcode never changes.
	Good model for how a good hash code will peform.
	Assume hashtable with chaining, no duplicate keys. 
	Perform find(k).  k hashes to a bucket b.
	Cost of the search is $1 + $1 for every entry in bucket b whose key is not k.
	suppose there are n keys in table besides k.
	V1, V2,... Vn: random variables of K
	for each ki,  Vi=1 if ki hashes to bucket b 

	Assume N buckets 
	Each key has probability 1/N hashing to bucket b.

	E[T] = 1 + n/N,

	The same analysis applies to insert and remove operations.  All three hash
		table operations take O(1)       expected                amortized time 
									hash code&collisions 		resizing 

	Quicksort 
			 	mergesort 

	Quicksort spends linear time of each level ( partioning lists)		 									
			(linear in # of boxes).

	Analyze expected depth one input key will reach.		
	Assume no 2 keys are equal.
	Random pivot: equally likely to be smallest key, second smallest ,third, ..., or largest. 
	

GARBAGE COLLECTION	

	The java virtual machine (JVM) that runs your program

	uses hidden data structures to manage memory.

Roots and Reachability

	An object your program might use again: live. Opposite is garbage- objects your program cannot reference again.

Root: any reference your program can access direclty.
	local variable on stack.
	class variable                  only reference variables.

Object is live if 
	 referenced by a root, or 
	 reference by a field in another live object.

	i.e. reachable from the roots.

	Garbage collectors run DFS from the roots, 

	Every object has a "visited" tag, invisible to your program.

Memoery Addresses 
	memory is array of bytes with addresses.
----------------------------
|   |   |   |   |   |   |   ...
----------------------------
  0   1   2   3  4    5   6

	Declare local variable <- naming a memory location.
	(java picks the address)

	Memory address = pointers 

Mark & Sweep Garbage Collection

	2 phases.

	Mark phase does a dfs from every root; marks all live objects.

	Sweep phase does pass over all object in memory. 
		Garbage is reclaimed.

		JVM  data structure keeps track of free & allocate memory.

Compaction 
	
	Fragmentation: tendency of free memory to get broken up into small piece. unable to allocate a large object despite lots of free memroy

	A compacting garbage collector moves object during sweep phase.

	References 
		In sun JVM, a reference is a handle. A handle is a pointer to a pointer.
		The "second pointers" are kept in a special tables.
			reference reference reference 

Copying Garbage Collection
	memory is divided into 2 spaces, old spare & new space. 
	Finds live object by dfs,
		when it encounter object in old spaces, it immediately moves i to new space. Compation included .		
	Next time, new space is relabeled "old" space, old space is relabeled "new space".

	Advantage: fast 
	Disadvantage: memory cut in half.

Generational Garbage Collection

most objects allocated by most programs have short lifetimes, while a few go on to survive through many garbage collection

A generational collector has 2 or more generations.
	can be different sizes.
	can change size.

sun 1.3 JVM
	
	Minor collections: frequent; only affect young generation
	major collections : cover all objects.

	special table of references from old objects to young is added to the roots for minor collections.

AUGMENTING DATA STRUCTURES
	pj3: set E of edges is hash & table adjacency list 

	2-3-4 Trees with Fast Neighbors

	No duplicate keys. 

	Given key k, determine whether k is in tree & what next smaller & larger keys are ,in O(1)time.

	Combine 2-3-4 tree with hash table.

	Maps key to record w/next smaller & larger keys .

	insert: determine by tree search in O(logn) time what next smaller/larger keys are.
			update all 3 keys records in hashtable ; O(1)time.

	Splay Trees with Node Information
			like the size and height of each subtree at each node

		We can answer the query "How many keys are there between x and y?" in O(logn) amortized time

		Strategy: set c =n . Deduct from c # of keys outside the range [x,y].
		find(x);//keys in root's left subtree are all less than x.

		 c=c-size (root's left subtree);
		 	if(root key < x){
		 	c--;  //possible
		 	}

		 finx(y);	
		 c=c-size(root's right subtree)
		 if(root key >y){
		 c--;
		 }
		 now,c is # of keys